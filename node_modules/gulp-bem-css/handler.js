/**
  * Create folders and stylesheet files for bem-blocks
  * from html-code
  * @author Alexander Gruzdkov
  * @param {string} html HTML source code
  * @param {string} [folder='src/blocks/'] Path for creating directories and stylesheet files
  * @param {string} [extension='css'] Extension of stylesheet files
  * @param {string} [elementSeparator='__'] Element separator in class names
  * @param {string} [modifierSeparator='--'] Modifier separator in class names
 *  @return {object|undefined} CSS-Tree
*/
async function run (html, folder = `src/blocks`, extension = 'css', elementSeparator = '__', modifierSeparator = '--', callback) {
  const htmlparser = require('htmlparser2');
  const fs = require('fs');
  const mkdirp = require('mkdirp');

  const elementSeparatorRegexp = new RegExp(`[^${elementSeparator}]${elementSeparator}[^${elementSeparator}]`, 'gi');
  const modifierSeparatorRegexp = new RegExp(`[^${modifierSeparator}]${modifierSeparator}[^${modifierSeparator}]`, 'gi');

  let tree = {};

  if (!callback) {
    callback = function () {
      return true;
    };
  }

  function createTree (classes) {
    classes.forEach(classSplit);
  }

  function classSplit (className) {
    if (detectBlock(className) !== undefined) {
      if (!tree.hasOwnProperty(className)) {
        tree[className] = {
          elements: {},
          modifiers: []
        };
      }
    }

    if (detectElement(className) !== undefined) {
      let element = detectElement(className);

      if (!tree.hasOwnProperty(element.blockName)) {
        tree[element.blockName] = {
          elements: {},
          modifiers: []
        };
        tree[element.blockName]['elements'][className] = {
          modifiers: []
        };
      } else {
        if (!tree[element.blockName].elements.hasOwnProperty(className)) {
          tree[element.blockName]['elements'][className] = {
            modifiers: []
          };
        }
      }
    }

    if (detectModifier(className) !== undefined) {
      let modifier = detectModifier(className);
      if (modifier.elementName === null) {
        if (!tree.hasOwnProperty(modifier.blockName)) {
          tree[modifier.blockName] = {
            elements: {},
            modifiers: [modifier.modifierName]
          };
        } else {
          if (!tree[modifier.blockName].modifiers.includes(modifier.modifierName)) {
            tree[modifier.blockName]['modifiers'].push(modifier.modifierName);
          }
        }
      } else {
        if (!tree.hasOwnProperty(modifier.blockName)) {
          tree[modifier.blockName] = {
            elements: {},
            modifiers: []
          };
          tree[modifier.blockName]['elements'][modifier.elementName] = {
            modifiers: [modifier.modifierName]
          };
        } else {
          if (!tree[modifier.blockName]['elements'].hasOwnProperty(modifier.elementName)) {
            tree[modifier.blockName]['elements'][modifier.elementName] = {
              modifiers: modifier.modifierName
            };
          } else {
            if (!tree[modifier.blockName]['elements'][modifier.elementName].modifiers.includes(modifier.modifierName)) {
              tree[modifier.blockName]['elements'][modifier.elementName].modifiers.push(modifier.modifierName);
            }
          }
        }
      }
    }
  }

  function detectBlock (className) {
    // let checkElementArray = className.split(elementSeparator);
    // let checkModifierArray = className.split(modifierSeparator);
    // if (checkElementArray.length <= 1 && checkModifierArray.length <= 1) {
    //   return className;
    // }
    if ((className.search(elementSeparatorRegexp) === -1) && (className.search(modifierSeparatorRegexp) === -1)) {
      return className;
    }
  }

  function detectElement (className) {
    if (className.search(modifierSeparatorRegexp) === -1) {
      let elementSeparatorIndex = className.search(elementSeparatorRegexp) + 1;
      if (elementSeparatorIndex > 0) {
        return {
          blockName: className.substr(0, elementSeparatorIndex),
          elementName: className
        };
      }
    }

    // let checkElementArray = className.split(elementSeparator);
    // let checkModifierArray = className.split(modifierSeparator);
    //
    // if (checkElementArray.length > 1 && checkModifierArray.length <= 1) {
    //   return {
    //     blockName: checkElementArray[0],
    //     elementName: className
    //   };
    // }
  }

  function detectModifier (className) {
    // let checkElementArray = className.split(elementSeparator);
    // let checkModifierArray = className.split(modifierSeparator);
    // if (checkModifierArray.length > 1) {
    //   return {
    //     blockName: checkElementArray.length > 1 ? checkElementArray[0] : checkModifierArray[0],
    //     elementName: checkElementArray.length > 1 ? checkModifierArray[0] : null,
    //     modifierName: className
    //   };
    // }

    let elementSeparatorIndex = className.search(elementSeparatorRegexp) + 1;
    let modifierSeparatorIndex = className.search(modifierSeparatorRegexp) + 1;

    if (className.search(modifierSeparatorRegexp) > -1) {
      return {
        blockName: className.substr(0, elementSeparatorIndex).length === 0 ? className.substr(0, modifierSeparatorIndex) : className.substr(0, elementSeparatorIndex),
        elementName: elementSeparatorIndex === 0 ? null : className.substr(0, modifierSeparatorIndex),
        modifierName: className
      };
    }
  }

  function createCssCode (blockName, block) {
    let result = `.${blockName} {\r\n\r\n}\r\n\r\n`;

    block.modifiers.forEach(modifier => {
      result = result + `.${blockName}.${modifier} {\r\n\r\n}\r\n\r\n`;
    });

    for (let elementName in block.elements) {
      result = result + `.${blockName} .${elementName} {\r\n\r\n}\r\n\r\n`;
      block.elements[elementName].modifiers.forEach(modifier => {
        result = result + `.${blockName} .${elementName}.${modifier} {\r\n\r\n}\r\n\r\n`;
      });
    }
    return result.substr(0, result.length - 3);
  }

  function checkDirectory (directory) {
    try {
      fs.statSync(directory);
    } catch (e) {
      mkdirp.sync(directory);
    }
  }

  function createFiles (tree) {
    let block;

    checkDirectory(`${folder}`);
    for (block in tree) {
      checkDirectory(`${folder}/${block}`);
      if (!fs.existsSync(`${folder}/${block}/${block}.${extension}`)) {
        fs.writeFileSync(`${folder}/${block}/${block}.${extension}`, createCssCode(block, tree[block]));
      }
    }
  }

  const parser = new htmlparser.Parser({
    onattribute: (name, value) => {
      let classes;
      if (name === 'class') {
        classes = value.split(' ');
        createTree(classes);
      }
    }
  }, {
    decodeEntities: true
  });

  parser.write(html);
  parser.end();
  createFiles(tree);
  return true;
};
module.exports = run;
